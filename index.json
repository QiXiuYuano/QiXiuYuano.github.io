[{"content":" ","date":"2023-08-14","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"2023-08-14","permalink":"/posts/","section":"ğŸ“šæ–‡ç« ","summary":"posts","title":"ğŸ“šæ–‡ç« "},{"content":"","date":"2023-08-14","permalink":"/tags/typora/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Typora"},{"content":" 1 å‡†å¤‡å·¥ä½œ # ä½¿ç”¨ä¸‰ä¸ªå·¥å…·ï¼šTypora +ã€€PicGo ï¼‹ã€€GitHub\néœ€è¦å…ˆä¸‹è½½å®‰è£…å¥½ Typora å’Œ PicGo\n2 Typoraè®¾ç½®æ˜¯å¦éšè—æ–‡ç« çš„å…ƒä¿¡æ¯å¦‚å‘å¸ƒæ—¥æœŸç­‰ # æ‰“å¼€Typoraå·¥å…·ï¼Œæ‰“å¼€èœå•æ â€”æ–‡ä»¶â€”åå¥½è®¾ç½®â€”å›¾åƒ ä¸Šä¼ æœåŠ¡é€‰æ‹©ï¼šPicGo;PicGoè·¯å¾„é€‰æ‹©PicGoå®‰è£…è·¯å¾„ä¸‹PicGo.exe 3 Githubé…ç½® # è¿›å…¥å®˜ç½‘https://github.com/æ³¨å†Œ/ç™»å½•è´¦å·ï¼Œæ–°å»ºä»“åº“ ç”Ÿæˆä¸ªäººä»¤ç‰Œï¼ˆPersonal access tokenï¼‰GitHubä¸»é¡µå³ä¸Šè§’è¿›å…¥Setting â€”\u0026gt; Developer settings æ³¨æ„ï¼šç”Ÿæˆçš„ç§äººä»¤ç‰Œä»…åœ¨ç”Ÿæˆæ—¶æ˜¾ç¤ºä¸€æ¬¡ï¼Œå¾€åGitHubä¸ä¼šå†æ˜¾ç¤ºï¼Œå› æ­¤è¦è‡ªå·±ä¿å­˜å¥½ï¼\n4 PicGoè®¾ç½® # æ‰“å¼€PicGoå·¥å…·ï¼Œé€‰æ‹©å›¾åºŠè®¾ç½®ï¼Œç‚¹å‡»GitHubå›¾åºŠ å„é€‰é¡¹è®¾ç½®å¦‚ä¸‹ï¼š è®¾å®šä»“åº“åï¼šGitHubç”¨æˆ·å/ä»“åº“å è®¾å®šåˆ†æ”¯åï¼šmain ï¼ˆGitHubä»2020å¹´èµ·ä¸»åˆ†æ”¯åä»masteræ”¹ä¸ºmainï¼‰ è®¾å®šTokenï¼š2.2ä¸­GitHubé…ç½®ç”Ÿæˆçš„ Personal access token è®¾å®šå­˜å‚¨è·¯å¾„ï¼šå³å›¾ç‰‡åœ¨ä»“åº“ä¿å­˜å›¾ç‰‡çš„æ–‡ä»¶å¤¹åï¼ˆå¯ä¸è®¾ç½®ï¼‰ è®¾å®šè‡ªå®šä¹‰åŸŸåï¼šhttps://cdn.jsdelivr.net/gh/GitHubç”¨æˆ·å/ä»“åº“åï¼ˆä½¿ç”¨jsDelivrå®ç°cdnåŠ é€Ÿï¼‰ è®¾ç½®å®Œæˆåç¡®å®šå³å¯ï¼\n5 æµ‹è¯• # æ‰“å¼€Typora â€”\u0026gt; åå¥½è®¾ç½® â€”\u0026gt; å›¾åƒ â€”\u0026gt; è®¾ç½®å¦‚ä¸‹ â€”\u0026gt; ç‚¹å‡»éªŒè¯å›¾ç‰‡ä¸Šä¼ é€‰é¡¹ï¼š å‡ºç°å¦‚ä¸‹éªŒè¯æˆåŠŸè¡¨æ˜Typoraé…ç½®æˆåŠŸ!å¾€ååœ¨Typoraä¸­æ’å…¥å›¾ç‰‡å³ä¼šè‡ªåŠ¨ä¸Šä¼ å›¾ç‰‡è‡³GitHubå›¾åºŠ ","date":"2023-08-14","permalink":"/posts/typora-picgo-github/","section":"ğŸ“šæ–‡ç« ","summary":"Typora+PicGo+Githubå®ç°è‡ªåŠ¨ä¸Šä¼ å›¾ç‰‡è‡³GitHubå›¾åºŠ","title":"Typoraè‡ªåŠ¨ä¸Šä¼ å›¾ç‰‡åˆ°GitHubå›¾åºŠ"},{"content":"","date":"2023-08-14","permalink":"/tags/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"tags","title":"ğŸ·ï¸æ ‡ç­¾"},{"content":"","date":"2022-12-10","permalink":"/tags/cockroachdb/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Cockroachdb"},{"content":"","date":"2022-12-10","permalink":"/tags/fly.io/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Fly.io"},{"content":"","date":"2022-12-10","permalink":"/tags/go/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Go"},{"content":"","date":"2022-12-10","permalink":"/tags/hugo/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Hugo"},{"content":" Inspiration and Introduction # Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks. One trend that has allowed server rendered content to be dynamic without serving a lot of Javascript uses a persistent websocket connection to synchronize state. The server generates pieces of html that it sends back to the client which then is only responsible for patching the DOM with simple html. A popular Javascript library to do this patching is morphdom that aims to be lightweight and fast.\nThe following are frameworks that use this approach and handle a lot more complexity than will be mentioned here. Check out their sites and documentation for more.\nPhoenix LiveView Hotwire Laravel Livewire Static site generators such as Hugo make it easy to create and serve static web content that is easily cached and delivered cheaply. In this post we will explore using a homegrown approach inspired by these frameworks to add dynamic content to this blog using Go and a little Javascript.\nCode for the blog is found at github.com/sdehm/sdehm-blog while code for this dynamic content server is found at github.com/sdehm/sdehm-blog-dynamic. Architecture Overview # The solution explored here includes a little bit of Javascript and CSS added to the static site and a single webserver written in Go. The client side Javascript is responsible for opening the websocket connection, listening for user interaction, and patching the DOM when messages from the server are received. The server will keep track of connections, listen for user interaction messages from the client, send messages with HTML updates to clients, and will also persist data as needed.\nThe stack for this implementation includes the following libraries and service providers.\nServer side websockets in Go with the gobwas websocket library Frontend DOM patching with morphdom Data persisted in CockroachDB Dynamic content server hosted on Fly.io The blog is a Hugo static site on GitHub Pages with the Blowfish theme Implementation # The dynamic components created by this implementation are a live view count and a comment section.\nThe live view count shows how many active connections there are on a given post. This is shown in the top of each post page and shown per post on the home page or posts page. The native Blowfish view count component is modified to show the live view count instead of the total view count. Screenshot showing the live view count icon which indicates how many viewers are currently connected. The comments section shows a new comment form and a list of all comments for a given post with the newest shown at the top. As users add comments they are updated live for anyone viewing the page. Screenshot showing the comment section with a new comment form and a list of all comments the post. You can see these features on this post and others on this site.\nClient Side # The custom Javascript added to the static content is found here. The custom CSS is found here.\ncustom.js # The socket\u0026rsquo;s onmessage function set here will first parse the json sent by the server and will switch on the type.\nThe connected event sets the connection id that the server will use to identify the connection. This message also includes the HTML content for the all of the comments for this particular post which is patched with morphdom. Additionally an event listener is started to handle comment form submissions to be explained later.\nThe Blowfish Hugo template allows creating a custom comment template which is used to create an empty placeholder div with an id of comments so it can be found later. When the event handler receives a morph type event it updates the element with a matching id with server provided HTML. Morphdom will handle diffing the changes and making the minimal updates required. This will be used to update the live view count.\nSimilarly, when the message is a prepend type the DOM is updated with the new HTML however this time it is prepended to the element with a matching id rather than replaced with morphdom. This allows new comments to show up at the top of the comment list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 socket.onmessage = (event) =\u0026gt; { const data = JSON.parse(event.data); switch (data.type) { case \u0026#34;connected\u0026#34;: connectionId = data.connection_id; console.log(\u0026#34;Connection ID: \u0026#34; + connectionId); morphdom(document.getElementById(\u0026#34;comments\u0026#34;), data.html); document .getElementById(\u0026#34;comment-form\u0026#34;) .addEventListener(\u0026#34;submit\u0026#34;, handleCommentSubmit); break; case \u0026#34;morph\u0026#34;: morphdom(document.getElementById(data.id), data.html); break; case \u0026#34;prepend\u0026#34;: template = document.createElement(\u0026#34;template\u0026#34;); template.innerHTML = data.html; document.getElementById(data.id).prepend(template.content); break; } }; Conclusion # This approach to dynamic content on a static site allows for a lot of flexibility and is enjoyable to work with. Having a persistent websocket connection opens up a lot of possibilities for real time dynamic content yet it remains fairly lightweight. The native features of the Go language make it easy to implement a simple websocket server that can handle many connections.\nAs a potential downside, websockets are pretty well established but there is still the potential of clients who do not support them or have reasons to disable them. If a user is not online then they will only receive the static content which makes it important to make sure that the static content can deliver appropriate value by itself.\nAreas of Improvement and Next Steps # A notable area of improvement is the lack of tests in this example. It would be interesting to see how the architecture and design changes when tests are added.\nA complete list of improvements and next steps includes:\nTests Defined contract for messages and code generation for client and server code. Better error handling Observability Markdown comments Cached data store GitHub Actions deployments Advanced websockets features such as compression Non-websocket fallback for more robust support ","date":"2022-12-10","permalink":"/posts/making-a-static-blog-dynamic/","section":"ğŸ“šæ–‡ç« ","summary":"Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks.","title":"Making a Static Blog Dynamic: Websockets and Morphdom with a Go Server"},{"content":"","date":"2022-12-10","permalink":"/tags/morphdom/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Morphdom"},{"content":"","date":"2022-12-10","permalink":"/tags/websockets/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Websockets"},{"content":"","date":"2022-06-14","permalink":"/tags/advantages/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Advantages"},{"content":"","date":"2022-06-14","permalink":"/tags/dynamic/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Dynamic"},{"content":"","date":"2022-06-14","permalink":"/tags/number/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Number"},{"content":"","date":"2022-06-14","permalink":"/tags/popular/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Popular"},{"content":"","date":"2022-06-14","permalink":"/tags/server/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Server"},{"content":"","date":"2022-06-14","permalink":"/tags/static/","section":"ğŸ·ï¸æ ‡ç­¾","summary":"","title":"Static"},{"content":" Inspiration and Introduction # Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks. One trend that has allowed server rendered content to be dynamic without serving a lot of Javascript uses a persistent websocket connection to synchronize state. The server generates pieces of html that it sends back to the client which then is only responsible for patching the DOM with simple html. A popular Javascript library to do this patching is morphdom that aims to be lightweight and fast.\nThe following are frameworks that use this approach and handle a lot more complexity than will be mentioned here. Check out their sites and documentation for more.\nPhoenix LiveView Hotwire Laravel Livewire Static site generators such as Hugo make it easy to create and serve static web content that is easily cached and delivered cheaply. In this post we will explore using a homegrown approach inspired by these frameworks to add dynamic content to this blog using Go and a little Javascript.\nCode for the blog is found at github.com/sdehm/sdehm-blog while code for this dynamic content server is found at github.com/sdehm/sdehm-blog-dynamic. Architecture Overview # The solution explored here includes a little bit of Javascript and CSS added to the static site and a single webserver written in Go. The client side Javascript is responsible for opening the websocket connection, listening for user interaction, and patching the DOM when messages from the server are received. The server will keep track of connections, listen for user interaction messages from the client, send messages with HTML updates to clients, and will also persist data as needed.\nThe stack for this implementation includes the following libraries and service providers.\nServer side websockets in Go with the gobwas websocket library Frontend DOM patching with morphdom Data persisted in CockroachDB Dynamic content server hosted on Fly.io The blog is a Hugo static site on GitHub Pages with the Blowfish theme Implementation # The dynamic components created by this implementation are a live view count and a comment section.\nThe live view count shows how many active connections there are on a given post. This is shown in the top of each post page and shown per post on the home page or posts page. The native Blowfish view count component is modified to show the live view count instead of the total view count. Screenshot showing the live view count icon which indicates how many viewers are currently connected. The comments section shows a new comment form and a list of all comments for a given post with the newest shown at the top. As users add comments they are updated live for anyone viewing the page. Screenshot showing the comment section with a new comment form and a list of all comments the post. You can see these features on this post and others on this site.\nClient Side # The custom Javascript added to the static content is found here. The custom CSS is found here.\ncustom.js # The socket\u0026rsquo;s onmessage function set here will first parse the json sent by the server and will switch on the type.\nThe connected event sets the connection id that the server will use to identify the connection. This message also includes the HTML content for the all of the comments for this particular post which is patched with morphdom. Additionally an event listener is started to handle comment form submissions to be explained later.\nThe Blowfish Hugo template allows creating a custom comment template which is used to create an empty placeholder div with an id of comments so it can be found later. When the event handler receives a morph type event it updates the element with a matching id with server provided HTML. Morphdom will handle diffing the changes and making the minimal updates required. This will be used to update the live view count.\nSimilarly, when the message is a prepend type the DOM is updated with the new HTML however this time it is prepended to the element with a matching id rather than replaced with morphdom. This allows new comments to show up at the top of the comment list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 socket.onmessage = (event) =\u0026gt; { const data = JSON.parse(event.data); switch (data.type) { case \u0026#34;connected\u0026#34;: connectionId = data.connection_id; console.log(\u0026#34;Connection ID: \u0026#34; + connectionId); morphdom(document.getElementById(\u0026#34;comments\u0026#34;), data.html); document .getElementById(\u0026#34;comment-form\u0026#34;) .addEventListener(\u0026#34;submit\u0026#34;, handleCommentSubmit); break; case \u0026#34;morph\u0026#34;: morphdom(document.getElementById(data.id), data.html); break; case \u0026#34;prepend\u0026#34;: template = document.createElement(\u0026#34;template\u0026#34;); template.innerHTML = data.html; document.getElementById(data.id).prepend(template.content); break; } }; Conclusion # This approach to dynamic content on a static site allows for a lot of flexibility and is enjoyable to work with. Having a persistent websocket connection opens up a lot of possibilities for real time dynamic content yet it remains fairly lightweight. The native features of the Go language make it easy to implement a simple websocket server that can handle many connections.\nAs a potential downside, websockets are pretty well established but there is still the potential of clients who do not support them or have reasons to disable them. If a user is not online then they will only receive the static content which makes it important to make sure that the static content can deliver appropriate value by itself.\nAreas of Improvement and Next Steps # A notable area of improvement is the lack of tests in this example. It would be interesting to see how the architecture and design changes when tests are added.\nA complete list of improvements and next steps includes:\nTests Defined contract for messages and code generation for client and server code. Better error handling Observability Markdown comments Cached data store GitHub Actions deployments Advanced websockets features such as compression Non-websocket fallback for more robust support ","date":"2022-06-14","permalink":"/posts/test-layout/","section":"ğŸ“šæ–‡ç« ","summary":"Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks.","title":"Static Blog Dynamic: Websockets and Morphdom with a Go Server"},{"content":" å…³äºåšå®¢ # ä¸€ç›´éƒ½æœ‰æƒ³å»ºç«‹ä¸€ä¸ªå±äºè‡ªå·±çš„åšå®¢ï¼Œä½†å› ä¸ºæ‡’ä¸€ç›´ç»™è€½æã€‚æ•…è€Œå†³å®šå»ºç«‹æ­¤åšå®¢å‘Šè¯«è‡ªå·±ä¸è¦æ‡’æƒ°ã€‚å¯¹äºåšå®¢çš„è§„åˆ’ï¼š # ä¿—è¯è¯´å¥½è®°æ€§ä¸å¦‚çƒ‚ç¬”å¤´ï¼Œæ— è®ºæ‰€å­¦ã€æ‰€è§ã€æ‰€æƒ³å°½é‡è®°å½•ä¸‹æ¥ã€‚ å¸Œæœ›æŠŠå†™åšå®¢ä¸€ç›´åšæŒä¸‹å»ã€‚ ","date":"0001-01-01","permalink":"/about/","section":"","summary":"","title":"ğŸ™‹ğŸ»â€â™‚ï¸å…³äº"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"ğŸ—ƒï¸åˆ†ç±»","summary":"categories","title":"ğŸ—ƒï¸åˆ†ç±»"},{"content":"","date":"0001-01-01","permalink":"/links/","section":"","summary":"links","title":"ğŸ¤å‹é“¾"}]