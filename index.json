[{"content":" ","date":"2023-08-14","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"2023-08-14","permalink":"/posts/","section":"📚文章","summary":"posts","title":"📚文章"},{"content":"","date":"2023-08-14","permalink":"/tags/typora/","section":"🏷️标签","summary":"","title":"Typora"},{"content":" 1 准备工作 # 使用三个工具：Typora +　PicGo ＋　GitHub\n需要先下载安装好 Typora 和 PicGo\n2 Typora设置是否隐藏文章的元信息如发布日期等 # 打开Typora工具，打开菜单栏—文件—偏好设置—图像 上传服务选择：PicGo;PicGo路径选择PicGo安装路径下PicGo.exe 3 Github配置 # 进入官网https://github.com/注册/登录账号，新建仓库 生成个人令牌（Personal access token）GitHub主页右上角进入Setting —\u0026gt; Developer settings 注意：生成的私人令牌仅在生成时显示一次，往后GitHub不会再显示，因此要自己保存好！\n4 PicGo设置 # 打开PicGo工具，选择图床设置，点击GitHub图床 各选项设置如下： 设定仓库名：GitHub用户名/仓库名 设定分支名：main （GitHub从2020年起主分支名从master改为main） 设定Token：2.2中GitHub配置生成的 Personal access token 设定存储路径：即图片在仓库保存图片的文件夹名（可不设置） 设定自定义域名：https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名（使用jsDelivr实现cdn加速） 设置完成后确定即可！\n5 测试 # 打开Typora —\u0026gt; 偏好设置 —\u0026gt; 图像 —\u0026gt; 设置如下 —\u0026gt; 点击验证图片上传选项： 出现如下验证成功表明Typora配置成功!往后在Typora中插入图片即会自动上传图片至GitHub图床 ","date":"2023-08-14","permalink":"/posts/typora-picgo-github/","section":"📚文章","summary":"Typora+PicGo+Github实现自动上传图片至GitHub图床","title":"Typora自动上传图片到GitHub图床"},{"content":"","date":"2023-08-14","permalink":"/tags/","section":"🏷️标签","summary":"tags","title":"🏷️标签"},{"content":"","date":"2022-12-10","permalink":"/tags/cockroachdb/","section":"🏷️标签","summary":"","title":"Cockroachdb"},{"content":"","date":"2022-12-10","permalink":"/tags/fly.io/","section":"🏷️标签","summary":"","title":"Fly.io"},{"content":"","date":"2022-12-10","permalink":"/tags/go/","section":"🏷️标签","summary":"","title":"Go"},{"content":"","date":"2022-12-10","permalink":"/tags/hugo/","section":"🏷️标签","summary":"","title":"Hugo"},{"content":" Inspiration and Introduction # Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks. One trend that has allowed server rendered content to be dynamic without serving a lot of Javascript uses a persistent websocket connection to synchronize state. The server generates pieces of html that it sends back to the client which then is only responsible for patching the DOM with simple html. A popular Javascript library to do this patching is morphdom that aims to be lightweight and fast.\nThe following are frameworks that use this approach and handle a lot more complexity than will be mentioned here. Check out their sites and documentation for more.\nPhoenix LiveView Hotwire Laravel Livewire Static site generators such as Hugo make it easy to create and serve static web content that is easily cached and delivered cheaply. In this post we will explore using a homegrown approach inspired by these frameworks to add dynamic content to this blog using Go and a little Javascript.\nCode for the blog is found at github.com/sdehm/sdehm-blog while code for this dynamic content server is found at github.com/sdehm/sdehm-blog-dynamic. Architecture Overview # The solution explored here includes a little bit of Javascript and CSS added to the static site and a single webserver written in Go. The client side Javascript is responsible for opening the websocket connection, listening for user interaction, and patching the DOM when messages from the server are received. The server will keep track of connections, listen for user interaction messages from the client, send messages with HTML updates to clients, and will also persist data as needed.\nThe stack for this implementation includes the following libraries and service providers.\nServer side websockets in Go with the gobwas websocket library Frontend DOM patching with morphdom Data persisted in CockroachDB Dynamic content server hosted on Fly.io The blog is a Hugo static site on GitHub Pages with the Blowfish theme Implementation # The dynamic components created by this implementation are a live view count and a comment section.\nThe live view count shows how many active connections there are on a given post. This is shown in the top of each post page and shown per post on the home page or posts page. The native Blowfish view count component is modified to show the live view count instead of the total view count. Screenshot showing the live view count icon which indicates how many viewers are currently connected. The comments section shows a new comment form and a list of all comments for a given post with the newest shown at the top. As users add comments they are updated live for anyone viewing the page. Screenshot showing the comment section with a new comment form and a list of all comments the post. You can see these features on this post and others on this site.\nClient Side # The custom Javascript added to the static content is found here. The custom CSS is found here.\ncustom.js # The socket\u0026rsquo;s onmessage function set here will first parse the json sent by the server and will switch on the type.\nThe connected event sets the connection id that the server will use to identify the connection. This message also includes the HTML content for the all of the comments for this particular post which is patched with morphdom. Additionally an event listener is started to handle comment form submissions to be explained later.\nThe Blowfish Hugo template allows creating a custom comment template which is used to create an empty placeholder div with an id of comments so it can be found later. When the event handler receives a morph type event it updates the element with a matching id with server provided HTML. Morphdom will handle diffing the changes and making the minimal updates required. This will be used to update the live view count.\nSimilarly, when the message is a prepend type the DOM is updated with the new HTML however this time it is prepended to the element with a matching id rather than replaced with morphdom. This allows new comments to show up at the top of the comment list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 socket.onmessage = (event) =\u0026gt; { const data = JSON.parse(event.data); switch (data.type) { case \u0026#34;connected\u0026#34;: connectionId = data.connection_id; console.log(\u0026#34;Connection ID: \u0026#34; + connectionId); morphdom(document.getElementById(\u0026#34;comments\u0026#34;), data.html); document .getElementById(\u0026#34;comment-form\u0026#34;) .addEventListener(\u0026#34;submit\u0026#34;, handleCommentSubmit); break; case \u0026#34;morph\u0026#34;: morphdom(document.getElementById(data.id), data.html); break; case \u0026#34;prepend\u0026#34;: template = document.createElement(\u0026#34;template\u0026#34;); template.innerHTML = data.html; document.getElementById(data.id).prepend(template.content); break; } }; Conclusion # This approach to dynamic content on a static site allows for a lot of flexibility and is enjoyable to work with. Having a persistent websocket connection opens up a lot of possibilities for real time dynamic content yet it remains fairly lightweight. The native features of the Go language make it easy to implement a simple websocket server that can handle many connections.\nAs a potential downside, websockets are pretty well established but there is still the potential of clients who do not support them or have reasons to disable them. If a user is not online then they will only receive the static content which makes it important to make sure that the static content can deliver appropriate value by itself.\nAreas of Improvement and Next Steps # A notable area of improvement is the lack of tests in this example. It would be interesting to see how the architecture and design changes when tests are added.\nA complete list of improvements and next steps includes:\nTests Defined contract for messages and code generation for client and server code. Better error handling Observability Markdown comments Cached data store GitHub Actions deployments Advanced websockets features such as compression Non-websocket fallback for more robust support ","date":"2022-12-10","permalink":"/posts/making-a-static-blog-dynamic/","section":"📚文章","summary":"Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks.","title":"Making a Static Blog Dynamic: Websockets and Morphdom with a Go Server"},{"content":"","date":"2022-12-10","permalink":"/tags/morphdom/","section":"🏷️标签","summary":"","title":"Morphdom"},{"content":"","date":"2022-12-10","permalink":"/tags/websockets/","section":"🏷️标签","summary":"","title":"Websockets"},{"content":"","date":"2022-06-14","permalink":"/tags/advantages/","section":"🏷️标签","summary":"","title":"Advantages"},{"content":"","date":"2022-06-14","permalink":"/tags/dynamic/","section":"🏷️标签","summary":"","title":"Dynamic"},{"content":"","date":"2022-06-14","permalink":"/tags/number/","section":"🏷️标签","summary":"","title":"Number"},{"content":"","date":"2022-06-14","permalink":"/tags/popular/","section":"🏷️标签","summary":"","title":"Popular"},{"content":"","date":"2022-06-14","permalink":"/tags/server/","section":"🏷️标签","summary":"","title":"Server"},{"content":"","date":"2022-06-14","permalink":"/tags/static/","section":"🏷️标签","summary":"","title":"Static"},{"content":" Inspiration and Introduction # Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks. One trend that has allowed server rendered content to be dynamic without serving a lot of Javascript uses a persistent websocket connection to synchronize state. The server generates pieces of html that it sends back to the client which then is only responsible for patching the DOM with simple html. A popular Javascript library to do this patching is morphdom that aims to be lightweight and fast.\nThe following are frameworks that use this approach and handle a lot more complexity than will be mentioned here. Check out their sites and documentation for more.\nPhoenix LiveView Hotwire Laravel Livewire Static site generators such as Hugo make it easy to create and serve static web content that is easily cached and delivered cheaply. In this post we will explore using a homegrown approach inspired by these frameworks to add dynamic content to this blog using Go and a little Javascript.\nCode for the blog is found at github.com/sdehm/sdehm-blog while code for this dynamic content server is found at github.com/sdehm/sdehm-blog-dynamic. Architecture Overview # The solution explored here includes a little bit of Javascript and CSS added to the static site and a single webserver written in Go. The client side Javascript is responsible for opening the websocket connection, listening for user interaction, and patching the DOM when messages from the server are received. The server will keep track of connections, listen for user interaction messages from the client, send messages with HTML updates to clients, and will also persist data as needed.\nThe stack for this implementation includes the following libraries and service providers.\nServer side websockets in Go with the gobwas websocket library Frontend DOM patching with morphdom Data persisted in CockroachDB Dynamic content server hosted on Fly.io The blog is a Hugo static site on GitHub Pages with the Blowfish theme Implementation # The dynamic components created by this implementation are a live view count and a comment section.\nThe live view count shows how many active connections there are on a given post. This is shown in the top of each post page and shown per post on the home page or posts page. The native Blowfish view count component is modified to show the live view count instead of the total view count. Screenshot showing the live view count icon which indicates how many viewers are currently connected. The comments section shows a new comment form and a list of all comments for a given post with the newest shown at the top. As users add comments they are updated live for anyone viewing the page. Screenshot showing the comment section with a new comment form and a list of all comments the post. You can see these features on this post and others on this site.\nClient Side # The custom Javascript added to the static content is found here. The custom CSS is found here.\ncustom.js # The socket\u0026rsquo;s onmessage function set here will first parse the json sent by the server and will switch on the type.\nThe connected event sets the connection id that the server will use to identify the connection. This message also includes the HTML content for the all of the comments for this particular post which is patched with morphdom. Additionally an event listener is started to handle comment form submissions to be explained later.\nThe Blowfish Hugo template allows creating a custom comment template which is used to create an empty placeholder div with an id of comments so it can be found later. When the event handler receives a morph type event it updates the element with a matching id with server provided HTML. Morphdom will handle diffing the changes and making the minimal updates required. This will be used to update the live view count.\nSimilarly, when the message is a prepend type the DOM is updated with the new HTML however this time it is prepended to the element with a matching id rather than replaced with morphdom. This allows new comments to show up at the top of the comment list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 socket.onmessage = (event) =\u0026gt; { const data = JSON.parse(event.data); switch (data.type) { case \u0026#34;connected\u0026#34;: connectionId = data.connection_id; console.log(\u0026#34;Connection ID: \u0026#34; + connectionId); morphdom(document.getElementById(\u0026#34;comments\u0026#34;), data.html); document .getElementById(\u0026#34;comment-form\u0026#34;) .addEventListener(\u0026#34;submit\u0026#34;, handleCommentSubmit); break; case \u0026#34;morph\u0026#34;: morphdom(document.getElementById(data.id), data.html); break; case \u0026#34;prepend\u0026#34;: template = document.createElement(\u0026#34;template\u0026#34;); template.innerHTML = data.html; document.getElementById(data.id).prepend(template.content); break; } }; Conclusion # This approach to dynamic content on a static site allows for a lot of flexibility and is enjoyable to work with. Having a persistent websocket connection opens up a lot of possibilities for real time dynamic content yet it remains fairly lightweight. The native features of the Go language make it easy to implement a simple websocket server that can handle many connections.\nAs a potential downside, websockets are pretty well established but there is still the potential of clients who do not support them or have reasons to disable them. If a user is not online then they will only receive the static content which makes it important to make sure that the static content can deliver appropriate value by itself.\nAreas of Improvement and Next Steps # A notable area of improvement is the lack of tests in this example. It would be interesting to see how the architecture and design changes when tests are added.\nA complete list of improvements and next steps includes:\nTests Defined contract for messages and code generation for client and server code. Better error handling Observability Markdown comments Cached data store GitHub Actions deployments Advanced websockets features such as compression Non-websocket fallback for more robust support ","date":"2022-06-14","permalink":"/posts/test-layout/","section":"📚文章","summary":"Server side rendering is becoming more popular and has a number of advantages over alternatively heavy client frameworks.","title":"Static Blog Dynamic: Websockets and Morphdom with a Go Server"},{"content":" 关于博客 # 一直都有想建立一个属于自己的博客，但因为懒一直给耽搁。故而决定建立此博客告诫自己不要懒惰。对于博客的规划： # 俗话说好记性不如烂笔头，无论所学、所见、所想尽量记录下来。 希望把写博客一直坚持下去。 ","date":"0001-01-01","permalink":"/about/","section":"","summary":"","title":"🙋🏻‍♂️关于"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"🗃️分类","summary":"categories","title":"🗃️分类"},{"content":"","date":"0001-01-01","permalink":"/links/","section":"","summary":"links","title":"🤝友链"}]